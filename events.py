from OSC import OSCServer
import threading, string
import pygame

def debug(text):
  print(text)

class OSCController:
  """ Checks the SavedOSC for a hot msg
  then creates an event based on the osc
  msg and posts the event
  """
  def __init__(self, evManager, savedOSC):
    self.evManager = evManager
    self.evManager.addListener(self)
    self.savedOSC = savedOSC
  def notify(self, event):
    if isinstance(event, TickEvent):
      path = self.savedOSC.path
      args = self.savedOSC.args
      fresh = self.savedOSC.fresh
      if fresh == "hot":
        # check for which is the main OSC target container
        # this is a good way to do it if you have lots of osc msgs
        # path = string.split( self.savedOSC.path, "/")[1]
        # if path == "test":
        debug("oscController recieved %s" % path)

        # see if osc matchs anything we want to recieve
        # and if so make an event than at the end post it
        # to the evManager
        event = None
        if path == "/test":
          # test - testing OSC recieved
          # if it has more then 2 arguments
          # find out whichbutton was pressed
          # /test p 0-3   <-- buton 0-3 was pressed
          # /test r 0-3   <-- buton 0-3 was released
          if len(args) > 1:
            # asume it was pressed
            button = args[1]
            event = ButtonPressedEvent(button)
        elif path == "/r":
          event = ButtonPressedEvent("r")
        elif path == "/r/runtime":
          # /r/runtime p 110
          # address p = play r = record 
          # /r/runtime state time_in_10ths_secs
          if len (args) > 0:
            runtime = args[1] 
            event = RuntimeEvent(runtime)
        elif path == "/r/play":
          event = ButtonPressedEvent(1)
        elif path == "/r/record":
          event = ButtonPressedEvent(2)
        elif path == "/r/stop":
          event = ButtonPressedEvent(3)
          # event2 = RuntimeEvent(0)
          # self.evManager.post(event2)
        elif path == "/r/switch":
          event = ButtonPressedEvent(4)
          
        # Post the event to listeners
        if not event == None:
          self.evManager.post(event)
          
        # Mark the saved OSC as old
        self.savedOSC.fresh = "cold"

class CPUSpinner:
  def __init__(self, evManager):
    self.evManager = evManager
    self.evManager.addListener(self)
  def run(self):
    self.running = True
    while self.running:
      ev = TickEvent()
      self.evManager.post(ev)
  def notify(self, event):
    if isinstance(event, QuitEvent):
      self.running = False

class KeyboardController:
  """Gets keyboard keys via pygame and sends to evManager"""
  def __init__(self, evManager):
    self.evManager = evManager
    self.evManager.addListener(self)

  def notify(self, event):
    if isinstance(event, TickEvent):
      for event in pygame.event.get():
        ev = None
        if event.type == pygame.KEYDOWN:
          # A keyboard key has been pressed
          # find out which one
          if event.key == pygame.K_1:
            ev = ButtonPressedEvent(1)
          elif event.key == pygame.K_2:
            ev = ButtonPressedEvent(2)
          elif event.key == pygame.K_3:
            ev = ButtonPressedEvent(3)
          elif event.key == pygame.K_4:
            ev = ButtonPressedEvent(4)
          elif event.key == pygame.K_q:
            ev = ButtonPressedEvent("q")
          elif event.key == pygame.K_w:
            ev = ButtonPressedEvent("w")
          elif event.key == pygame.K_s:
            ev = ButtonPressedEvent("s")
          elif event.key == pygame.K_d:
            ev = ButtonPressedEvent("d")
          elif event.key == pygame.K_r:
            ev = ButtonPressedEvent("r")
          elif event.key == pygame.K_t:
            ev = ButtonPressedEvent("t")
          elif event.key == pygame.K_5:
            ev = ButtonPressedEvent(5)
          elif event.key == pygame.K_ESCAPE:
            ev = QuitEvent()
        elif event.type == pygame.QUIT:
          ev = QuitEvent()
        # - - - - Post it - - - -  - - - - -
        # If event was one of the ones we are
        # looking for post it to the evManager
        if not ev == None:
          self.evManager.post(ev)
      # End of the for loop
    
class Event:
  """This is a superclass for any events that might
  be generated by an object and sent to the EventManager
  """
  pass

class TickEvent(Event):
  def __init__(self):
    self.name = "butts"

class ButtonPressedEvent(Event):
  def __init__(self, button):
    self.button = button

class RuntimeEvent(Event):
  def __init__(self, runtime):
    self.runtime = runtime


class QuitEvent(Event):
  pass

class EventManager:
  """This object is reponsible for being the mediator between the PygameView
  and the OSCReceivedController
  """
  def __init__(self):
    from weakref import WeakKeyDictionary
    self.listeners = WeakKeyDictionary()
  def addListener(self, listener):
    self.listeners[listener] = 1

  def removeListener(self, listener):
    if listener in self.listeners.keys():
      del self.listeners[ listener ]

  def post(self, event):
    if not isinstance(event, TickEvent):
      debug("This event was posted %s" % event.__class__.__name__)
    for listener in self.listeners.keys():
      # Note: if weakref has died, it will be
      # Automatically removed, so we dont
      # have to worry about it showing up in listeners
      listener.notify(event)

